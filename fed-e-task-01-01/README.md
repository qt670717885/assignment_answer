### 01

答案 ： 10

原因 ： 本题使用var创建了a数组与i变量，他们的声明会提升到最外层。当循环赋值i变量时，会根据a[i]创建匿名函数。函数的声明也会存在提升。并且这里的函数并没有去调用。当最后a[6]调用时，i的赋值已经完成，因为循环中i被赋值为10.a[6]只是函数的名称，所以打印出来的i的值为10.如果想对应循环i的值打印对应的值可以将var i= 0替换为let i = 0.原因是这里使用let关键字时会形成块级作用域。i变量不存在状态提升。



### 02

答案 ： 运行结果会报错

原因 ： 一开始在外层使用var定义了tmp变量并赋值为123，执行条件语句，为真进入后打印tmp时一开始是tmp是为123的，但是再往下使用let定义了tmp变量。这里条件语句中就形成了一个块级作用域。这就造成了引用变量在定义变量之前，造成是暂时性时区。所以代码会报错。



### 03

答案：

```
var arr = [12,34,32,89,4]
const min = Math.min(...arr)
```



### 04

答案：

- var声明变量时存在变量提升，也就是说先声明后赋值。允许引用变量在声明变量之前，虽然不提倡这么做。可以修改var定义的变量的值。var允许重复定义同一名称的变量
- let是ES6新增命令，let定义的变量仅在块级作用域内有效，let定义的变量不存在状态提升。外部无法调用块级作用域内的let变量，不会污染全局变量。引用变量必须在声明变量之后。可以修改let定义的变量的值。let不允许在同一块级作用域重复定义同一名称的变量。
- const是ES6新增命令，const定义的变量仅在块级作用域有效，const定义的变量不存在状态提升。外部无法调用块级作用域内的const变量。引用变量必须放在声明变量之后。const声明的是常量，只读，const保存的是内存地址，所以修改值会报错，但为对象，数组添加属性和元素则不会。const不允许在同一块级作用域重复定义同一名称的变量。



### 05

答案 ： 20

原因 ： 代码中使用的是箭头函数，箭头函数的this指向是在上下文中对象this指向，箭头函数this是在定义函数时就绑定了，而不是在调用执行的时候绑定。所以它指向的是obj，obj.a === 20,所以答案为20



### 06

答案 ： 

​	symbol类型为ES6新增的一种原始类型，用来表示独一无二的值。

​	用途 ： 

- 可以作用对象属性名，避免属性名称重复

```js
const obj = {}
obj[Symbol()] = 'foo'
```

- 可以定义为常量，枚举时不会出现重复的值,

```js
const NUM_ONE = 1
const NUM_TWO = 2
```

- 模拟私有属性

```
const sayHello = Symbol('sayHello')
class Person {
	[sayHello]() {
		console.log('hello')
	}
}
```



### 07

答案：

js的数据类型分为基本数据类型和引用数据类型。深浅拷贝的问题存在于引用数据类型，如对象，数组。基本数据类型时存放在栈中的，引用数据类型时存放在堆中的，然后在栈中存放的是引用数据类型在堆内存中的地址。以对象为例，浅拷贝就是直接复制了指向这个对象的指针（引用地址），深拷贝则是复制出另外一个完全相同的对象。

浅拷贝出来的另一个对象更改上面的某一个属性，原先的对象的属性也会改变，而深拷贝的话就不会。具体的实现深浅拷贝方法如下：

```

const obj = {name : 'q',age : 18}

//浅拷贝
const obj2 = obj;

const obj3 = Object.assign({},obj);

//深拷贝
const obj4 = JSON.parse(JSON.stringify(obj))

const a = [1,2,3]
const b = [...a]
```





### 08

答案 ： 

​	JS的异步编程 ： 

​		js是一门单线程的语言，同一时间只能执行一个任务，这就会出现一个任务执行时间过长造成阻塞的问题。所以js需要一种可以处理不确定多久完成任务的一种机制。这就是异步编程。js代码执行时按同步执行，遇到异步后跳过异步任务执行下一个任务，让异步在异步队列中执行，执行完的异步任务放在消息队列中，待同步任务执行完成后将消息队列中的异步任务再取出拿到返回值。

​	Event Loop :

​		Event Loop就是事件循环，它的作用就是解决js单线程运行时不会阻塞的一种机制。

​		js代码开始执行时将任务压入调用栈，调用栈先去判断任务为同步任务还是异步任务，如果是同步任务，直接就在栈中等待执行，如果是异步任务就会被安排到异步队列中，等待执行完成。当异步队列对应的某一个异步任务执行完后就把任务放入消息队列中等待调用。当c调用栈中同步任务执行完后，就从消息队列中依次异步任务压入调用栈。二Event Loop就是去不停检查调用栈中是否还有任务，如果没有就去看消息队列中有没有任务，如果有就压入调用栈，如此反复。

​	宏任务，微任务：

​		宏任务一般有整体同步的代码，setTimeout，I/O等。微任务有promise，Node环境中有Process.nextTick。

在js异步中事件循环时遇到宏任务先执行宏任务，执行完宏任务去检查有没有微任务，有微任务就再去执行微任务。等微任务执行完后再去执行下一个宏任务，如此反复。



### 09

```js
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        var a = 'hello'
        resolve(a)
    },10)
}).then(function(res){
    return new Promise((resolve,reject)=>{
        setTimeout(() => {
            var b = 'lagou'
            resolve(`${res} ${b}`) 
        },10)
    })
    
}).then(function(res){
    setTimeout(() => {
        var c = 'i love you'
        console.log(`${res} ${c}`)
    },10)
})
```



### 10

答案 ： 

​	typeScript是JavaScript的超集。ts可以编译成纯js代码。ts主要解决js动态弱类型语言的问题。增加js代码的约束力。保证在编写时即能发现语法上的类型错误。但ts知识静态的检查类型，当编译报错时还是会编译出对应的js文件。



### 11

答案：

- ​	优点 ：
  1. ts是渐进式的，对编写很友好，你完全可以用js的标准写ts
  2. ts增加了代码的可读性和可维护性
  3. ts引入了很多js没有的概念，如类，泛型，接口等，并强了代码的约束力
  4. ts的生态很好
  5. ts完全支持js的环境，包括浏览器，Node，RN等都可以使用ts

- 缺点
  1. 有一定的学习成本
  2. 会增加一定的开发成本
  3. 对于掌握不熟练的前端开发人员某些概念不容易理解，像泛型，接口。